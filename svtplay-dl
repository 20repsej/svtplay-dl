#!/usr/bin/env python
import sys
if sys.version_info > (3, 0):
    from urllib.request import Request, urlopen
    from urllib.error import HTTPError, URLError
    from urllib.parse import urlparse, parse_qs, unquote_plus, quote_plus
else:
    from urllib2 import Request, urlopen, HTTPError, URLError
    from urlparse import urlparse, parse_qs
    from urllib import unquote_plus, quote_plus

import re
import os
import subprocess
from optparse import OptionParser
import xml.etree.ElementTree as ET
import shlex
import json
import time

__version__ = "0.7.2012.05.19"

class Common(object):
    logtosderr = False
    silent = False
    def getdata(self, url, method="GET", header="", data=""):
        """ Get the page to parse it for streams """
        request = Request(url)
        request.add_header('User-Agent', 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3')

        if len(header) > 0:
            request.add_header('Content-Type', header)
        if len(data) > 0:
            request.add_data(data)
        try:
            response = urlopen(request)
        except HTTPError as e:
            self.to_console("Something wrong with that url")
            self.to_console("Error code: %s" % e.code)
            sys.exit(5)
        except URLError as e:
            self.to_console("Something wrong with that url")
            self.to_console("Error code: %s" % e.reason)
            sys.exit(5)
        except ValueError as e:
            self.to_console("Try adding http:// before the url")
            sys.exit(5)
        if sys.version_info > (3, 0):
            data = response.read().decode('utf-8')
        else:
            try:
                data = response.read()
            except socket.error as e:
                self.to_console("Lost the connection to the server")
                sys.exit(5)
        response.close()
        return data

    def progress(self, byte, total):
        """ Print some info about how much we have downloaded """
        ratio = float(byte) / total
        percent = round(ratio*100, 2)
        tlen = str(len(str(total)))
        fmt = "Downloaded %"+tlen+"dkB of %dkB bytes (% 3.2f%%)"
        progresstr = fmt % (byte >> 10, total >> 10, percent)

        columns = int(os.getenv("COLUMNS", "80"))
        if len(progresstr) < columns - 13:
            p = int((columns - len(progresstr) - 3) * ratio)
            q = int((columns - len(progresstr) - 3) * (1 - ratio))
            progresstr = "[" + ("#" * p) + (" " * q) + "] " + progresstr
        sys.stderr.write(progresstr + '\r')

        if byte >= total:
            sys.stderr.write('\n')

        sys.stderr.flush()

    def getrtmp(self, url, output, live, other, resume):
        """ Get the stream from RTMP """
        args = ""
        if live:
            args = "%s -v" % args

        if resume:
            args = "%s -e" % args

        extension = re.search("(\....)$", url)
        if output != "-":
            if not extension:
                extension = re.search("-y (.+):[-_a-z0-9\/]", other)
                if not extension:
                    output = output + ".flv"
                else:
                    output = output + "." + extension.group(1)
            else:
                output = output + extension.group(1)
            args = args + " -o %s" % output
        if self.silent or output == "-":
            args = "%s -q" % args
        rtmpdump = "rtmpdump -r %s %s %s" % (url, args, other)
        command = shlex.split(str(rtmpdump))
        subprocess.call(command)

    def gethttp(self, url, output):
        """ Get the stream from HTTP """
        response = urlopen(url)
        total_size = response.info()['Content-Length']
        total_size = int(total_size)
        bytes_so_far = 0
        if output != "-":
            extension = re.search("(\....)$", url)
            if extension:
                output = output + extension.group(1)
            file_d = open(output,"wb")

        lastprogress = 0
        while 1:
            chunk = response.read(8192)
            bytes_so_far += len(chunk)

            if not chunk:
                break

            if output != "-":
                file_d.write(chunk)
                now = time.time()
                if lastprogress + 1 < now:
                    lastprogress = now
                    self.progress(bytes_so_far, total_size)
            else:
                self.to_consoleb(chunk)

        if output != "-":
            file_d.close()

    def to_console(self, message, endl=True):
        if not self.silent:
            term = [u'',  u'\n'][endl]
            message = message + term
            console = [sys.stdout, sys.stderr][self.logtosderr]
            console.write(message)

    def to_consoleb(self, data):
        try:
            sys.stdout.write(data)
        except IOError as e:
            sys.exit(5)


class Justin():
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url):
        other = "-a ondemand"
        data = self.common.getdata(url)
        data = re.sub("<(\d+)", "<_\g<1>", data)
        data = re.sub("</(\d+)", "</_\g<1>", data)
        xml = ET.XML(data)
        if sys.version_info < (2, 7):
            sa = list(xml)
        else:
            sa = list(xml)
        streams = {}
        for i in sa:
            if i.tag[1:][:-1] != "iv":
                try:
                    stream = {}
                    stream["token"] = i.find("token").text
                    stream["url"] = i.find("connect").text + "/" + i.find("play").text
                    streams[i.find("video_height").text] = stream
                except AttributeError:
                    None
        sort = []
        for key in sorted(streams.keys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()
        try:
            test = streams[str(self.quality)]
        except KeyError:
            self.common.to_console("Err: cant find that quality. try: ")
            for i in sort:
                self.common.to_console(str(i))
            sys.exit(4)

        other = "-j '%s' -W %s" % (test["token"], self.resume)
        self.resume = False
        self.common.getrtmp(test["url"], self.output, self.live, other, self.resume)

class Justin2():
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url):
        other = "-a ondemand"
        data = self.common.getdata(url)
        xml = ET.XML(data)
        url = xml.find("archive").find("video_file_url").text
        self.output = self.output + url[-4:]
        self.common.gethttp(url, self.output)

class Hbo():
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url):
        data = self.common.getdata(url)
        xml = ET.XML(data)
        videoid = xml.find("content")[1].find("videoId").text
        url = "http://render.cdn.hbo.com/data/content/global/videos/data/%s.xml" % videoid
        data = self.common.getdata(url)
        xml = ET.XML(data)
        ss = xml.find("videos")
        if sys.version_info < (2, 7):
            sa = list(ss.getiterator("size"))
        else:
            sa = list(ss.iter("size"))
        streams = {}
        for i in sa:
            stream = {}
            stream["path"] = i.find("tv14").find("path").text
            streams[i.attrib["width"]] = stream

        sort = []
        for key in sorted(streams.keys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()

        try:
            test = streams[str(self.quality)]
        except KeyError:
            self.common.to_console("Err: cant find that quality. try: ")
            for i in sort:
                self.common.to_console(str(i))
            sys.exit(4)

        if not self.output:
            self.output = os.path.basename(streams[str(self.quality)]["path"])
            self.common.to_console("Outfile: ", self.output)

        self.common.getrtmp(streams[str(self.quality)]["path"], self.output, self.live, "", self.resume)

class Sr():
    def __init__(self, common, output, quality, live, other, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.other = other
        self.resume = resume

    def get(self, url):
        url = url + self.other
        data = self.common.getdata(url)
        xml = ET.XML(data)
        url = xml.find("entry").find("ref").attrib["href"]

        if not self.output:
            self.output = os.path.basename(url)
            self.common.to_console("Outfile: ", self.output)

        self.common.gethttp(url, self.output)

class Urplay():
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url):
        other = "-a ondemand"
        data = self.common.getdata(url)
        match = re.search('file=(.*)\&plugins', data)
        if match:
            path = "mp" + match.group(1)[-1] + ":" + match.group(1)
            other = "-a ondemand -y %s" % path

            if not self.output:
                self.output = os.path.basename(path)
                self.common.to_console("Outfile: ", self.output)

            self.common.getrtmp("rtmp://streaming.ur.se/", self.output, self.live, other, self.resume)

class Qbrick():
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url):
        data = self.common.getdata(url)
        xml = ET.XML(data)
        server = xml.find("head").find("meta").attrib["base"]
        streams = xml.find("body").find("switch")
        if sys.version_info < (2, 7):
            sa = list(streams.getiterator("video"))
        else:
            sa = list(streams.iter("video"))
        streams = {}
        for i in sa:
            streams[int(i.attrib["system-bitrate"])] = i.attrib["src"]

        sort = []
        for key in sorted(streams.keys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()

        try:
            path = streams[int(self.quality)]
        except KeyError:
            self.common.to_console("Err: cant find that quality. try: ")
            for i in sort:
                self.common.to_console(str(i))
            sys.exit(4)

        if not self.output:
            self.output = os.path.basename(streams[int(self.quality)])
            self.common.to_console("Outfile: ", self.output)

        other = "-y %s" % path
        self.common.getrtmp(server, self.output, self.live, other, self.resume)

class Kanal5():
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url):
        data = json.loads(self.common.getdata(url))
        steambaseurl = data["streamBaseUrl"]
        streams = {}

        for i in data["streams"]:
            stream = {}
            stream["source"] = i["source"]
            streams[i["bitrate"]] = stream

        sort = []
        for key in sorted(streams.keys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()

        try:
            test = streams[int(self.quality)]
        except KeyError:
            self.common.to_console("Err: cant find that quality. try: ")
            for i in sort:
                self.common.to_console(str(i))
            sys.exit(4)

        if not self.output:
            self.output = os.path.basename(streams[int(self.quality)]["source"])
            self.common.to_console("Outfile: ", self.output)


        filename = streams[int(self.quality)]["source"]
        match = re.search("^(.*):", filename)
        self.output  = "%s.%s" % (self.output, match.group(1))
        other = "-W %s -y %s " % ("http://www.kanal5play.se/flash/StandardPlayer.swf", filename)
        self.common.getrtmp(steambaseurl, self.output, self.live, other, self.resume)

class Kanal9():
    def __init__(self, common, output, quality, live, other, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.other = other
        self.resume = resume

    def get(self, url):
        try:
            from pyamf import remoting
        except ImportError:
            self.common.to_console("You need to install pyamf to download content from kanal5 and kanal9")
            self.common.to_console("In debian the package is called python-pyamf")
            sys.exit(2)

        player_id = 811317479001
        publisher_id = 22710239001
        const = "9f79dd85c3703b8674de883265d8c9e606360c2e"
        env = remoting.Envelope(amfVersion=3)
        env.bodies.append(("/1", remoting.Request(target="com.brightcove.player.runtime.PlayerMediaFacade.findMediaById", body=[const, player_id, self.other, publisher_id], envelope=env)))
        env = str(remoting.encode(env).read())
        url = "http://" + url + "/services/messagebroker/amf?playerKey=AQ~~,AAAABUmivxk~,SnCsFJuhbr0vfwrPJJSL03znlhz-e9bk"
        header = "application/x-amf"
        data = self.common.getdata(url, "POST", header, env)
        streams = {}

        for i in remoting.decode(data).bodies[0][1].body['renditions']:
            stream = {}
            stream["uri"] = i["defaultURL"]
            streams[i["encodingRate"]] = stream

        sort = []
        for key in sorted(streams.keys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()

        try:
            test = streams[int(self.quality)]
        except KeyError:
            self.common.to_console("Err: cant find that quality. try: ")
            for i in sort:
                self.common.to_console(str(i))
            sys.exit(4)

        if not self.output:
            self.output = os.path.basename(streams[int(self.quality)]["uri"])
            self.common.to_console("Outfile: ", self.output)

        filename = streams[int(self.quality)]["uri"]
        match = re.search("(rtmp[e]{0,1}://.*)\&(.*)$", filename)
        other = "-W %s -y %s " % ("http://admin.brightcove.com/viewer/us1.25.04.01.2011-05-24182704/connection/ExternalConnection_2.swf", match.group(2))
        self.common.getrtmp(match.group(1), self.output, self.live, other, self.resume)

class Expressen():
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url):
        other = ""
        data = self.common.getdata(url)
        xml = ET.XML(data)
        ss = xml.find("vurls")
        if sys.version_info < (2, 7):
            sa = list(ss.getiterator("vurl"))
        else:
            sa = list(ss.iter("vurl"))
        streams = {}

        for i in sa:
            streams[i.attrib["bitrate"]] = i.text

        sort = []
        for key in sorted(streams.keys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()

        try:
            test = streams[str(self.quality)]
        except KeyError:
            self.common.to_console("Err: cant find that quality. try: ")
            for i in sort:
                self.common.to_console(str(i))
            sys.exit(4)

        if not self.output:
            self.output = os.path.basename(streams[str(self.quality)])
            self.common.to_console("Outfile: %s" % self.output)

        filename = streams[str(self.quality)]
        match = re.search("rtmp://([0-9a-z\.]+/[0-9]+/)(.*).flv", filename)

        filename = "rtmp://%s" % match.group(1)
        other = "-y %s" % match.group(2)

        self.common.getrtmp(filename, self.output, self.live, other, self.resume)

class Aftonbladet():
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url, start):
        data = self.common.getdata(url)
        xml = ET.XML(data)
        url = xml.find("articleElement").find("mediaElement").find("baseUrl").text
        path = xml.find("articleElement").find("mediaElement").find("media").attrib["url"]
        other = "-y %s" % path

        if start > 0:
            other = other + " -A %s" % str(start)

        if url == None:
            self.common.to_console("Error: Cant find any video on that page")
            sys.exit(3)

        if not self.output:
            self.output = os.path.basename(path)
            self.common.to_console("Outfile: %s " % self.output)

        if url[0:4] == "rtmp":
            self.common.getrtmp(url, self.output, self.live, other, self.resume)
        else:
            filename = url + path
            self.common.gethttp(filename, self.output)

class Viaplay(Common):
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url):
        other = ""
        data = self.common.getdata(url)
        xml = ET.XML(data)
        filename = xml.find("Product").find("Videos").find("Video").find("Url").text

        if filename[:4] == "http":
            data = self.common.getdata(filename)
            xml = ET.XML(data)
            filename = xml.find("Url").text

        if not self.output:
            self.output = os.path.basename(filename)
            self.common.to_console("Outfile: %s" % self.output)

        other = "-W http://flvplayer.viastream.viasat.tv/play/swf/player110516.swf?rnd=1315434062"
        self.common.getrtmp(filename, self.output, self.live, other, self.resume)

class Tv4play():
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url):
        data = self.common.getdata(url)
        xml = ET.XML(data)
        ss = xml.find("items")
        if sys.version_info < (2, 7):
            sa = list(ss.getiterator("item"))
        else:
            sa = list(ss.iter("item"))
        streams = {}
        sa.pop(len(sa)-1)

        for i in sa:
            stream = {}
            stream["uri"] = i.find("base").text
            stream["path"] = i.find("url").text
            streams[i.find("bitrate").text] = stream
        
        sort = []
        for key in sorted(streams.keys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()

        try:
            test = streams[str(self.quality)]
        except KeyError:
            self.common.to_console("Err: cant find that quality. try: ")
            for i in sort:
                self.common.to_console(str(i))
            sys.exit(4)

        other = "-W http://www.tv4play.se/flash/tv4playflashlets.swf -y %s" % streams[str(self.quality)]["path"]

        if not self.output:
            self.output = os.path.basename(streams[str(self.quality)]["path"])
            self.common.to_console("Outfile: %s" % self.output)

        self.common.getrtmp(streams[str(self.quality)]["uri"], self.output, self.live, other, self.resume)

class Svtplay():
    def __init__(self, common, output, quality, live, resume):
        self.common = common
        self.output = output
        self.quality = quality
        self.live = live
        self.resume = resume

    def get(self, url):
        other = "-W http://svtplay.se/flash/svtplayer-2012.1.swf"
        data = self.common.getdata(url)
        match = re.search('dynamicStreams=(.*)\&amp\;background', data)
        if match:
            new = match.group(1)
            tmp = new.split("|")
            streams = {}
            for f in tmp:
                match = re.search('url:(.*)\,bitrate:([0-9]+)', f)
                streams[int(match.group(2))] = match.group(1)
            if not self.quality:
                filename = streams[sorted(streams.keys()).pop()]
            else:
                try:
                    filename = streams[int(self.quality)]
                except (ValueError, KeyError):
                    self.common.to_console("Err: Cant find that quality. try 2400 (720p), 1400 (high), 850 (mid) or 320 (low)")
                    sys.exit(4)
        else:
            match = re.search('pathflv=(.*)\&amp\;background', data)
            if not match:
                self.common.to_console("Err: cant find stream")
                sys.exit(3)
            filename = match.group(1)

        if not self.output:
            self.output = os.path.basename(filename)
            self.common.to_console("Outfile: %s" % self.output)

        if filename[0:4] == "rtmp":
            self.common.getrtmp(filename, self.output, self.live, other, self.resume)
        else:
            self.common.gethttp(filename, self.output)

def main():
    """ Main program """
    usage = "usage: %prog [options] url"
    parser = OptionParser(usage=usage, version=__version__)
    parser.add_option("-o", "--output",
        metavar="OUTPUT", help="Outputs to the given filename.")
    parser.add_option("-r", "--resume",
        action="store_true", dest="resume", default=False,
        help="Resume a download")
    parser.add_option("-l", "--live",
        action="store_true", dest="live", default=False,
        help="Enable for live streams")
    parser.add_option("-s", "--silent",
        action="store_true", dest="silent", default=False)
    parser.add_option("-q", "--quality",
        metavar="quality", help="Choose what format to download.\nIt will download the best format by default")
    (options, args) = parser.parse_args()
    if len(args) != 1:
        parser.error("incorrect number of arguments")
    output = options.output
    live = options.live
    quality = options.quality
    resume = options.resume
    silent = options.silent
    common = Common()
    common.silent = silent

    url = args[0]
    if not output:
        data = common.getdata(url)
        match = re.search("(?i)<title>\s*(.*?)\s*</title>", data)
        if match:
            if sys.version_info > (3, 0):
                title = re.sub('[^\w\s-]', '', match.group(1)).strip().lower()
                output = re.sub('[-\s]+', '-', title)
            else:
                title = unicode(re.sub('[^\w\s-]', '', match.group(1)).strip().lower())
                output = unicode(re.sub('[-\s]+', '-', title))

    if output == "-":
        common.logtosderr = True

    if re.findall("(twitch|justin).tv", url):
        parse = urlparse(url)
        match = re.search("/b/(\d+)", parse.path)
        if match:
            url = "http://api.justin.tv/api/broadcast/by_archive/%s.xml?onsite=true" % match.group(1)
            justin = Justin2(common, output, quality, live, resume)
            justin.get(url)
        else:
            match = re.search("/(.*)", parse.path)
            if match:
                user = match.group(1)
                data = common.getdata(url)
                match = re.search("embedSWF\(\"(.*)\", \"live", data)
                if not match:
                    common.to_console("Error: Cant find swf file.")
                other = match.group(1)
                url = "http://usher.justin.tv/find/%s.xml?type=any&p=2321" % user
                live = True
                justin = Justin(common, output, quality, live, other)
                justin.get(url)

    if re.findall("hbo.com", url):
        parse = urlparse(url)
        try:
            other = parse[5]
        except KeyError:
            common.to_console("Something wrong with that url")
            sys.exit(2)
        match = re.search("^/(.*).html", other)
        if not match:
            common.to_console("Cant find video file")
            sys.exit(2)
        url = "http://www.hbo.com/data/content/" + match.group(1) + ".xml"
        hbo = Hbo(common, output, quality, live, resume)
        hbo.get(url)

    if re.findall("tv4play", url):
        parse = urlparse(url)
        try:
            vid = parse_qs(parse[4])["videoid"][0]
        except KeyError:
            common.to_console("Cant find video file")
            sys.exit(2)
        url = "http://premium.tv4play.se/api/web/asset/%s/play" % vid
        tv4play = Tv4play(common, output, quality, live, resume)
        tv4play.get(url)

    elif re.findall("(tv3play|tv6play|tv8play)", url):
        parse = urlparse(url)
        match = re.search('\/play\/(.*)/', parse.path)
        if not match:
            common.to_console("Cant find video file")
            sys.exit(2)
        url = "http://viastream.viasat.tv/PlayProduct/%s" % match.group(1)
        viaplay = Viaplay(common, output, quality, live, resume)
        viaplay.get(url)

    elif re.findall("viaplay", url):
        parse = urlparse(url)
        match = re.search('\/Tv/channels\/[a-zA-Z0-9-]+\/[a-zA-Z0-9-]+\/[a-zA-Z0-9-]+\/(.*)/', parse.path)
        if not match:
            common.to_console("Cant find video file")
            sys.exit(2)
        url = "http://viasat.web.entriq.net/nw/article/view/%s/?tf=players/TV6.tpl" % match.group(1)
        data = common.getdata(url)
        match = re.search("id:'(.*)'", data)
        if not match:
            common.to_console("Cant find video file")
        url = "http://viastream.viasat.tv/PlayProduct/%s" % match.group(1)
        viaplay = Viaplay(common, output, quality, live, resume)
        viaplay.get(url)

    elif re.findall("aftonbladet", url):
        parse = urlparse(url)
        data = common.getdata(url)
        match = re.search("abTvArticlePlayer-player-(.*)-[0-9]+-[0-9]+-clickOverlay", data)
        if not match:
            common.to_console("Cant find video file")
            sys.exit(2)
        try:
            start = parse_qs(parse[4])["start"][0]
        except KeyError:
            start = 0
        url = "http://www.aftonbladet.se/resource/webbtv/article/%s/player" % match.group(1)
        aftonbladet = Aftonbladet(common, output, quality, live, resume)
        aftonbladet.get(url, start)

    elif re.findall("expressen", url):
        parse = urlparse(url)
        match = re.search("/(.*[\/\+].*)/", unquote_plus(parse.path))
        if not match:
            common.to_console("Cant find video file")
            sys.exit(2)
        url = "http://tv.expressen.se/%s/?standAlone=true&output=xml" % quote_plus(match.group(1))
        expressen = Expressen(common, output, quality, live, resume)
        expressen.get(url)

    elif re.findall("kanal5play", url):
        match = re.search(".*video/([0-9]+)", url)
        if not match:
            common.to_console("Cant find video file")
            sys.exit(2)
        url = "http://www.kanal5play.se/api/getVideo?format=FLASH&videoId=%s" % match.group(1)
        kanal5 = Kanal5(common, output, quality, live, resume)
        kanal5.get(url)


    elif re.findall("kanal9play", url):
        data = common.getdata(url)
        match = re.search("@videoPlayer\" value=\"(.*)\"", data)
        if not match:
            common.to_console("Cant find video file")
            sys.exit(2)
        kanal9 = Kanal9(common, output, quality, live, match.group(1), resume)
        kanal9.get("c.brightcove.com")

    elif re.findall("dn.se", url):
        data = common.getdata(url)
        match = re.search("data-qbrick-mcid=\"([0-9A-F]+)\"", data)
        if not match:
            match = re.search("mediaId = \'([0-9A-F]+)\';", data)
            if not match:
                common.to_console("Cant find video file")
                sys.exit(2)
            mcid = match.group(1) + "DE1BA107"
        else:
            mcid = match.group(1)
        qbrick = Qbrick(common, output, quality, live, resume)
        host = "http://vms.api.qbrick.com/rest/v3/getsingleplayer/" + mcid
        data = common.getdata(host)
        xml = ET.XML(data)
        try:
            url = xml.find("media").find("item").find("playlist").find("stream").find("format").find("substream").text
        except AttributeError:
            common.to_console("Cant find video file")
            sys.exit(2)
        qbrick.get(url)

    elif re.findall("di.se", url):
        data = common.getdata(url)
        match = re.search("ccid: \"(.*)\"\,", data)
        if not match:
            common.to_console("Cant find video file")
            sys.exit(2)
        qbrick = Qbrick(common, output, quality, live, resume)
        host = "http://vms.api.qbrick.com/rest/v3/getplayer/" + match.group(1)
        data = common.getdata(host)
        xml = ET.XML(data)
        try:
            host = xml.find("media").find("item").find("playlist").find("stream").find("format").find("substream").text
        except AttributeError:
            common.to_console("Cant find stream")
            sys.exit(2)
        qbrick.get(host)

    elif re.findall("svd.se", url):
        match = re.search("_([0-9]+)\.svd", url)
        if not match:
            common.to_console("Cant find video file")
            sys.exit(2)

        data = common.getdata("http://www.svd.se/?service=ajax&type=webTvClip&articleId=" + match.group(1))
        match = re.search("mcid=([A-F0-9]+)\&width=", data)

        if not match:
            common.to_console("Cant find video file")
            sys.exit(2)

        qbrick = Qbrick(common, output, quality, live, resume)
        host = "http://vms.api.qbrick.com/rest/v3/getsingleplayer/" + match.group(1)
        data = common.getdata(host)
        xml = ET.XML(data)
        try:
            host = xml.find("media").find("item").find("playlist").find("stream").find("format").find("substream").text
        except AttributeError:
            common.to_console("Cant find video file")
            sys.exit(2)
        qbrick.get(host)

    elif re.findall("urplay.se", url):
        urplay = Urplay(common, output, quality, live, resume)
        urplay.get(url)

    elif re.findall("sverigesradio", url):
        data = common.getdata(url)
        parse = urlparse(url)
        try:
            metafile = parse_qs(parse[4])["metafile"][0]
            other = "%s?%s" % (parse[2], parse[4])
        except KeyError:
            match = re.search("linkUrl=(.*)\;isButton=", data)
            if not match:
                common.to_console("Cant find video file")
                sys.exit(2)
            other = unquote_plus(match.group(1))
        sr = Sr(common, output, quality, live, other, resume)
        sr.get("http://sverigesradio.se")

    else:
        svtplay = Svtplay(common, output, quality, live, resume)
        svtplay.get(url)


if __name__ == "__main__":
    main()
