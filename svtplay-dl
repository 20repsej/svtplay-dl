#!/usr/bin/env python
import re
import urllib
import urllib2
import sys
import os
import subprocess
from optparse import OptionParser
import urlparse
import xml.etree.ElementTree as ET
import shlex
from pyamf import remoting

class Common(object):
    def getdata(self, url, method="GET", header="", data=""):
        """ Get the page to parse it for streams """
        request = urllib2.Request(url)
        request.add_header('User-Agent', 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3')
        if len(header) > 0:
            request.add_header('Content-Type', header)
        if len(data) > 0:
            request.add_data(data)
        try:
            response = urllib2.urlopen(request)
        except urllib2.HTTPError:
            print "Something wrong with that url"
            sys.exit(2)

        data = response.read()
        response.close()
        return data

    def calc_data(self, byte, total):
        """ Print some info about how much we have downloaded """
        percent = float(byte) / total
        percent = round(percent*100, 2)
        sys.stdout.write("Downloaded %d of %d bytes (%.2f%%)\r" % (byte, total, percent))
        if byte >= total:
            sys.stdout.write('\n')

    def getrtmp(self, url, output, live, other):
        """ Get the stream from RTMP """
        encrypted = ""
        if url[4:5] == "e":
            # For encrypted streams
            encrypted = "-l 2"
        if live:
            live = "-v"

        rtmpdump = "rtmpdump -r %s -o %s %s %s %s" % (url, output, encrypted, other, live)
        command = shlex.split(str(rtmpdump))
        subprocess.call(command)

    def gethttp(self, url, output):
        """ Get the stream from HTTP """
        response = urllib2.urlopen(url)
        total_size = response.info().getheader('Content-Length').strip()
        total_size = int(total_size)
        bytes_so_far = 0
        file_d = open(output,"wb")

        while 1:
            chunk = response.read(8192)
            bytes_so_far += len(chunk)

            if not chunk:
                break

            file_d.write(chunk)
            self.calc_data(bytes_so_far, total_size)

        file_d.close()

class Kanal5(Common):
    def __init__(self, output, quality, live, other):
        self.output = output
        self.quality = quality
        self.live = live
        self.other = other

    def get(self, url):
        player_id = 811317479001
        publisher_id = 22710239001
        const = "9f79dd85c3703b8674de883265d8c9e606360c2e"
        env = remoting.Envelope(amfVersion=3)
        env.bodies.append(("/1", remoting.Request(target="com.brightcove.player.runtime.PlayerMediaFacade.findMediaById", body=[const, player_id, self.other, publisher_id], envelope=env)))
        env = str(remoting.encode(env).read())
        url = "http://" + url + "/services/messagebroker/amf?playerKey=AQ~~,AAAABUmivxk~,SnCsFJuhbr0vfwrPJJSL03znlhz-e9bk"
        header = "application/x-amf"
        data = self.getdata(url, "POST", header, env)
        streams = {}

        for i in remoting.decode(data).bodies[0][1].body['renditions']:
            stream = {}
            stream["uri"] = i["defaultURL"]
            streams[i["encodingRate"]] = stream

        sort = []
        for key in sorted(streams.iterkeys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()

        try:
            test = streams[int(self.quality)]
        except:
            print "Err: cant find that quality. try: "
            for i in sort:
                print i
            sys.exit(2)

        if not self.output:
            self.output = os.path.basename(streams[int(self.quality)]["uri"])
            print "Outfile: ", self.output

        filename = streams[int(self.quality)]["uri"]
        match = re.search("(rtmp[e]{0,1}://.*)\&(.*)$", filename)
        other = "-y %s -W %s" % (match.group(2), "http://admin.brightcove.com/viewer/us1.25.04.01.2011-05-24182704/connection/ExternalConnection_2.swf")
        self.getrtmp(match.group(1), self.output, self.live, other)

class Expressen(Common):
    def __init__(self, output, quality, live):
        self.output = output
        self.quality = quality
        self.live = live

    def get(self, url):
        other = ""
        data = self.getdata(url)
        xml = ET.XML(data)
        ss = xml.find("vurls")
        sa = list(ss.iter("vurl"))
        streams = {}

        for i in sa:
            streams[i.attrib["bitrate"]] = i.text

        sort = []
        for key in sorted(streams.iterkeys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()

        try:
            test = streams[str(self.quality)]
        except:
            print "Err: cant find that quality. try: "
            for i in sort:
                print i
            sys.exit(2)

        if not self.output:
            self.output = os.path.basename(streams[str(self.quality)])
            print "Outfile: ", self.output

        filename = streams[str(self.quality)]
        match = re.search("rtmp://([0-9a-z\.]+/[0-9]+/)(.*).flv", filename)

        filename = "rtmp://%s" % match.group(1)
        other = "-y %s" % match.group(2)

        self.getrtmp(filename, self.output, self.live, other)

class Aftonbladet(Common):
    def __init__(self, output, quality, live):
        self.output = output
        self.quality = quality
        self.live = live

    def get(self, url, start):
        data = self.getdata(url)
        xml = ET.XML(data)
        url = xml.find("articleElement").find("mediaElement").find("baseUrl").text
        path = xml.find("articleElement").find("mediaElement").find("media").attrib["url"]
        other = "-y %s" % path
        if start > 0:
            other = other + " -A %s" % str(start)

        if not self.output:
            self.output = os.path.basename(path)
            print "Outfile: ", self.output

        if url[0:4] == "rtmp":
            self.getrtmp(url, self.output, self.live, other)
        else:
            filename = url + path
            self.gethttp(filename, self.output)

class Viaplay(Common):
    def __init__(self, output, quality, live):
        self.output = output
        self.quality = quality
        self.live = live

    def get(self, url):
        other = ""
        data = self.getdata(url)
        xml = ET.XML(data)
        filename = xml.find("Product").find("Videos").find("Video").find("Url").text
        if filename[:4] == "http":
            data = self.getdata(filename)
            xml = ET.XML(data)
            filename = xml.find("Url").text
        if not self.output:
            self.output = os.path.basename(filename)
            print "Outfile: ", self.output
        other = "-W http://flvplayer.viastream.viasat.tv/play/swf/player110516.swf?rnd=1315434062"
        self.getrtmp(filename, self.output, self.live, other)

class Tv4play(Common):
    def __init__(self, output, quality, live):
        self.output = output
        self.quality = quality
        self.live = live

    def get(self, url):
        data = self.getdata(url)
        xml = ET.XML(data)
        ss = xml.find("items")
        sa = list(ss.iter("item"))
        streams = {}
        sa.pop(len(sa)-1)

        for i in sa:
            stream = {}
            stream["uri"] = i.find("base").text
            stream["path"] = i.find("url").text
            streams[i.find("bitrate").text] = stream
        
        sort = []
        for key in sorted(streams.iterkeys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()

        try:
            test = streams[str(self.quality)]
        except:
            print "Err: cant find that quality. try: "
            for i in sort:
                print i
            sys.exit(2)

        other = "-W http://www.tv4play.se/flash/tv4playflashlets.swf -y %s" % streams[str(self.quality)]["path"]

        if not self.output:
            self.output = os.path.basename(streams[str(self.quality)]["path"])
            print "Outfile: ", self.output

        self.getrtmp(streams[str(self.quality)]["uri"], self.output, self.live, other)

class Svtplay(Common):
    def __init__(self, output, quality, live):
        self.output = output
        self.quality = quality
        self.live = live

    def get(self, url):
        other = ""
        data = self.getdata(url)
        match = re.search('dynamicStreams=(.*)\&amp\;background', data)
        if match:
            new = match.group(1)
            tmp = new.split("|")
            streams = {}
            for f in tmp:
                match = re.search('url:(.*)\,bitrate:([0-9]+)', f)
                streams[int(match.group(2))] = match.group(1)
            if not self.quality:
                filename = streams[sorted(streams.keys()).pop()]
            else:
                try:
                    filename = streams[int(self.quality)]
                except (ValueError, KeyError):
                    print "Err: Cant find that quality. try 2400 (720p), 1400 (high), 850 (mid) or 320 (low)"
                    sys.exit(2)
        else:
            match = re.search('pathflv=(.*)\&amp\;background', data)
            if not match:
                print "Err: cant find stream"
                sys.exit(2)
            filename = match.group(1)

        if not self.output:
            self.output = os.path.basename(filename)
            print "Outfile: ", self.output

        if filename[0:4] == "rtmp":
            self.getrtmp(filename, self.output, self.live, other)
        else:
            self.gethttp(filename, self.output)

def main():
    """ Main program """
    usage = "usage: %prog [options] url"
    parser = OptionParser(usage=usage)
    parser.add_option("-o", "--output",
        metavar="OUTPUT", help="Outputs to the given filename.")
    parser.add_option("-l", "--live",
        action="store_true", dest="live", default=False,
        help="Enable for live streams")
    parser.add_option("-q", "--quality",
        metavar="quality", help="Choose what format to download.\nIt will download the best format by default")
    (options, args) = parser.parse_args()
    if len(args) != 1:
        parser.error("incorrect number of arguments")
    output = options.output
    live = options.live
    quality = options.quality
    url = args[0]

    if re.findall("tv4play", url):
        parse = urlparse.urlparse(url)
        try:
            vid = urlparse.parse_qs(parse[4])["videoid"][0]
        except KeyError:
            print "Something wrong with that url"
            sys.exit(2)
        url = "http://premium.tv4play.se/api/web/asset/%s/play" % vid
        tv4play = Tv4play(output, quality, live)
        tv4play.get(url)

    elif re.findall("(tv3play|tv6play|tv8play)", url):
        parse = urlparse.urlparse(url)
        match = re.search('\/play\/(.*)/', parse.path)
        if not match:
            print "Something wrong with that url"
            sys.exit(2)
        url = "http://viastream.viasat.tv/PlayProduct/%s" % match.group(1)
        viaplay = Viaplay(output, quality, live)
        viaplay.get(url)

    elif re.findall("viaplay", url):
        common = Common()
        parse = urlparse.urlparse(url)
        match = re.search('\/Tv/channels\/[a-zA-Z0-9-]+\/[a-zA-Z0-9-]+\/[a-zA-Z0-9-]+\/(.*)/', parse.path)
        if not match:
            print "Something wrong with that url"
            sys.exit(2)
        url = "http://viasat.web.entriq.net/nw/article/view/%s/?tf=players/TV6.tpl" % match.group(1)
        data = common.getdata(url)
        match = re.search("id:'(.*)'", data)
        if not match:
            print "Something wrong with that url"
        url = "http://viastream.viasat.tv/PlayProduct/%s" % match.group(1)
        viaplay = Viaplay(output, quality, live)
        viaplay.get(url)

    elif re.findall("aftonbladet", url):
        parse = urlparse.urlparse(url)
        match = re.search(".*/article([0-9]+)\.ab", parse.path)
        if not match:
            print "Something wrong with that url"
            sys.exit(2)
        try:
            start = urlparse.parse_qs(parse[4])["start"][0]
        except KeyError:
            start = 0
        url = "http://www.aftonbladet.se/resource/webbtv/article/%s/player" % match.group(1)
        aftonbladet = Aftonbladet(output, quality, live)
        aftonbladet.get(url, start)

    elif re.findall("expressen", url):
        parse = urlparse.urlparse(url)
        match = re.search("/(.*[\/\+].*)/", urllib.unquote_plus(parse.path))
        if not match:
            print "Something wrong with that url"
            sys.exit(2)
        url = "http://tv.expressen.se/%s/?standAlone=true&output=xml" % urllib.quote_plus(match.group(1))
        print match.group(1)
        expressen = Expressen(output, quality, live)
        expressen.get(url)

    elif re.findall("(kanal5play|kanal9play)", url):
        common = Common()
        data = common.getdata(url)
        match = re.search("@videoPlayer\" value=\"(.*)\"", data)
        if not match:
            print "Something wrong with that url"
            sys.exit(2)
        kanal5 = Kanal5(output, quality, live, match.group(1))
        kanal5.get("c.brightcove.com")

    else:
        svtplay = Svtplay(output, quality, live)
        svtplay.get(url)


if __name__ == "__main__":
    main()
