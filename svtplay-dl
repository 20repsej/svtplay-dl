#!/usr/bin/env python
import re
import urllib2
import sys
import os
import subprocess
from optparse import OptionParser
import urlparse
import xml.etree.ElementTree as ET
import shlex

class Common(object):
    def getdata(self, url):
        """ Get the page to parse it for streams """
        request = urllib2.Request(url)
        request.add_header = [('User-Agent', 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3')]
        try:
            response = urllib2.urlopen(request)
        except urllib2.HTTPError:
            print "Something wrong with that url"
            sys.exit(2)

        data = response.read()
        response.close()
        return data

    def calc_data(self, byte, total):
        """ Print some info about how much we have downloaded """
        percent = float(byte) / total
        percent = round(percent*100, 2)
        sys.stdout.write("Downloaded %d of %d bytes (%.2f%%)\r" % (byte, total, percent))
        if byte >= total:
            sys.stdout.write('\n')

    def getrtmp(self, url, output, live, other):
        """ Get the stream from RTMP """
        encrypted =""
        live = ""
        if url[4:5] == "e":
            # For encrypted streams
            encrypted = "-l 2"
        if live:
           live = "-v"

        rtmpdump = "rtmpdump -r %s -o %s %s %s %s" % (url, output, encrypted, other, live)
        command = shlex.split(rtmpdump)
        subprocess.call(command)

    def gethttp(self, url, output):
        """ Get the stream from HTTP """
        response = urllib2.urlopen(url)
        total_size = response.info().getheader('Content-Length').strip()
        total_size = int(total_size)
        bytes_so_far = 0
        file_d = open(output,"wb")

        while 1:
            chunk = response.read(8192)
            bytes_so_far += len(chunk)

            if not chunk:
                break

            file_d.write(chunk)
            self.calc_data(bytes_so_far, total_size)

        file_d.close()

class Viaplay(Common):
    def __init__(self, output, quality, live):
        self.output = output
        self.quality = quality
        self.live = live

    def get(self, url):
        other = ""
        data = self.getdata(url)
        xml = ET.XML(data)
        ss = xml.find("Product").find("Videos").find("Video").find("Url").text
        if ss[:4] == "http":
            data = self.getdata(ss)
            xml = ET.XML(data)
            ss = xml.find("Url").text
        if not self.output:
            self.output = os.path.basename(ss)
            print "Outfile: ", self.output
        other = "-W http://flvplayer.viastream.viasat.tv/play/swf/player110516.swf?rnd=1315434062"
        self.getrtmp(ss, self.output, self.live, other)

class Tv4play(Common):
    def __init__(self, output, quality, live):
        self.output = output
        self.quality = quality
        self.live = live

    def get(self, url):
        data = self.getdata(url)
        xml = ET.XML(data)
        ss = xml.find("items")
        sa = list(ss.iter("item"))
        streams = {}
        sa.pop(len(sa)-1)

        for i in sa:
            stream = {}
            stream["uri"] = i.find("base").text
            stream["path"] = i.find("url").text
            streams[i.find("bitrate").text] = stream
        
        sort = []
        for key in sorted(streams.iterkeys()):
            sort.append(int(key))
            sort = sorted(sort)

        if not self.quality:
            self.quality = sort.pop()

        try:
            other = "-W http://www.tv4play.se/flash/tv4playflashlets.swf -y %s" % streams[str(self.quality)]["path"]
        except (ValueError, KeyError):
            print "Err: Cant find that quality. try 2500, 1500, 800 or 300"
            sys.exit(2)

        if not self.output:
           self.output = os.path.basename(streams[str(self.quality)]["path"])
           print "Outfile: ", self.output
        self.getrtmp(streams[str(self.quality)]["uri"], self.output, self.live, other)

class Svtplay(Common):
    def __init__(self, output, quality, live):
        self.output = output
        self.quality = quality
        self.live = live

    def get(self, url):
        data = self.getdata(url)
        match = re.search('dynamicStreams=(.*)\&amp\;background', data)
        if match:
            new = match.group(1)
            tmp = new.split("|")
            streams = {}
            for f in tmp:
                match = re.search('url:(.*)\,bitrate:([0-9]+)', f)
                streams[int(match.group(2))] = match.group(1)
            if not self.quality:
                stream = streams[sorted(streams.keys()).pop()]
            else:
                try:
                    stream = streams[int(self.quality)]
                except (ValueError, KeyError):
                    print "Err: Cant find that quality. try 2400 (720p), 1400 (high), 850 (mid) or 320 (low)"
                    sys.exit(2)
        else:
            match = re.search('pathflv=(.*)\&amp\;background', data)
            if not match:
                print "Err: cant find stream"
                sys.exit(2)
            stream = match.group(1)

        if not self.output:
           self.output = os.path.basename(stream)
           print "Outfile: ", self.output

        if stream[0:4] == "rtmp":
            self.getrtmp(stream, self.output, self.live, other)
        else:
            self.gethttp(stream,self.output)

def main():
    """ Main program """
    usage = "usage: %prog [options] url"
    parser = OptionParser(usage=usage)
    parser.add_option("-o", "--output",
        metavar="OUTPUT", help="Outputs to the given filename.")
    parser.add_option("-l", "--live",
        action="store_true", dest="live", default=False,
        help="Enable for live streams")
    parser.add_option("-q", "--quality",
        metavar="quality", help="Choose what format to download.\nIt will download the best format by default")
    (options, args) = parser.parse_args()
    if len(args) != 1:
        parser.error("incorrect number of arguments")
    output = options.output
    live = options.live
    quality = options.quality
    url = args[0]

    if re.findall("tv4play", url):
        parse = urlparse.urlparse(url)
        try:
            vid = urlparse.parse_qs(parse[4])["videoid"][0]
        except KeyError:
            print "Something wrong with that url"
            sys.exit(2)
        url = "http://premium.tv4play.se/api/web/asset/%s/play" % vid
        tv4play = Tv4play(output, quality, live)
        tv4play.get(url)

    elif re.findall("(tv3play|tv6play|tv8play)", url):
        parse = urlparse.urlparse(url)
        match = re.search('\/play\/(.*)/', parse.path)
        if not match:
            print "Something wrong with that url"
            sys.exit(2)
        url = "http://viastream.viasat.tv/PlayProduct/%s" % match.group(1)
        viaplay = Viaplay(output, quality, live)
        viaplay.get(url)

    elif re.findall("viaplay", url):
        common = Common()
        parse = urlparse.urlparse(url)
        match = re.search('\/Tv/channels\/[a-zA-Z0-9-]+\/[a-zA-Z0-9-]+\/[a-zA-Z0-9-]+\/(.*)/', parse.path)
        if not match:
            print "Something wrong with that url"
            sys.exit(2)
        url = "http://viasat.web.entriq.net/nw/article/view/%s/?tf=players/TV6.tpl" % match.group(1)
        data = common.getdata(url)
        match = re.search("id:'(.*)'", data)
        if not match:
            print "Something wrong with that url"
        url = "http://viastream.viasat.tv/PlayProduct/%s" % match.group(1)
        viaplay = Viaplay(output, quality, live)
        viaplay.get(url)

    else:
        svtplay = Svtplay(output, quality, live)
        svtplay.get(url)


if __name__ == "__main__":
    main()
