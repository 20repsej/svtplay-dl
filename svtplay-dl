#!/usr/bin/env python
import re
import urllib2
import sys
import os
import subprocess
from optparse import OptionParser

def getdata(url):
    """ Get the page to parse it for streams """
    request = urllib2.Request(url)
    request.add_header = [('User-Agent', 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3')]
    response = urllib2.urlopen(request)
    data = response.read()
    response.close()
    return data

def calc_data(byte, total):
    """ Print some info about how much we have downloaded """
    percent = float(byte) / total
    percent = round(percent*100, 2)
    sys.stdout.write("Downloaded %d of %d bytes (%.2f%%)\r" % (byte, total, percent))
    if byte >= total:
        sys.stdout.write('\n')

def getrtmp(url, output, live):
    """ Get the stream from RTMP """
    other, other2 = ""
    if url[4:5] == "e":
        # For encrypted streams
        other = "-l 2"
    if live:
       other2 = "-v"

    command = ["/usr/bin/rtmpdump", "-r", url, "-o", output, other, other2]
    subprocess.call(command)

def gethttp(url, output):
    """ Get the stream from HTTP """
    response = urllib2.urlopen(url)
    total_size = response.info().getheader('Content-Length').strip()
    total_size = int(total_size)
    bytes_so_far = 0
    file_d = open(output,"wb")

    while 1:
        chunk = response.read(8192)
        bytes_so_far += len(chunk)
        
        if not chunk:
            break

        file_d.write(chunk)
        calc_data(bytes_so_far, total_size)

    file_d.close()

def main():
    """ Main program """
    usage = "usage: %prog [options] url"
    parser = OptionParser(usage=usage)
    parser.add_option("-o", "--output",
        metavar="OUTPUT", help="Outputs to the given filename.")
    parser.add_option("-l", "--live",
        action="store_true", dest="live", default=False,
        help="Enable for live streams")
    parser.add_option("-q", "--quality",
        metavar="quality", help="Choose what format to download.\nIt will download the best format by default")
    (options, args) = parser.parse_args()
    if len(args) != 1:
        parser.error("incorrect number of arguments")
    output = options.output
    live = options.live
    quality = options.quality
    data = getdata(args[0])
    match = re.search('dynamicStreams=(.*)\&amp\;background', data)
    if match:
        new = match.group(1)
        tmp = new.split("|")
        streams = {}
        for f in tmp:
            match = re.search('url:(.*)\,bitrate:([0-9]+)', f)
            streams[int(match.group(2))] = match.group(1)
        if not quality:
            stream = streams[sorted(streams.keys()).pop()]
        else:
            try:
                stream = streams[int(quality)]
            except ValueError:
                print "Err: Cant find that quality. try 2400 (720p), 1400 (high), 850 (mid) or 320 (low)"
                sys.exit(2)
            except KeyError:
                print "Err: Cant find that quality. try 2400 (720p), 1400 (high), 850 (mid) or 320 (low)"
                sys.exit(2)
    else:
        match = re.search('pathflv=(.*)\&amp\;background', data)
        if not match:
            print "Err: cant find stream"
            sys.exit(2)
        stream = match.group(1)

    if not output:
       output = os.path.basename(stream)
       print "Outfile: ", output

    if stream[0:4] == "rtmp":
        getrtmp(stream, output, live)
    else:
        gethttp(stream, output)

if __name__ == "__main__":
    main()
